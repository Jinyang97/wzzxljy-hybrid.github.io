<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>碳原子杂化轨道成键模拟</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* 样式保持不变，与之前相同 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #0a0a0a;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff7e5f, #feb47b);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .hybridization-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .hybridization-option {
            padding: 12px 24px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #b3c7ff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .hybridization-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-3px);
        }
        
        .hybridization-option.active {
            background: linear-gradient(90deg, #4a6ee0, #6a8aff);
            color: white;
            border-color: #6a8aff;
            box-shadow: 0 0 15px rgba(106, 138, 255, 0.5);
        }
        
        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .orbital-diagrams {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }
        
        .orbital-diagram {
            width: 200px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .orbital-diagram h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #ff9e7d;
        }
        
        .energy-levels {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .energy-level {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .orbital-row {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .orbital-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .electron {
            font-size: 16px;
            font-weight: bold;
            color: white;
        }
        
        .electron.up {
            color: #4cd964;
        }
        
        .electron.down {
            color: #ff7e5f;
            transform: rotate(180deg);
        }
        
        .orbital-label {
            font-size: 14px;
            color: #b3c7ff;
            text-align: center;
        }
        
        .orbital-toggle {
            width: 20px;
            height: 20px;
        }
        
        .excitation-toggle {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            color: #b3c7ff;
        }
        
        .visualization {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #threeCanvas {
            width: 100%;
            height: 100%;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(106, 138, 255, 0.7);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }
        
        .zoom-btn:hover {
            background: rgba(106, 138, 255, 0.9);
            transform: scale(1.1);
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            gap: 20px;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-item input {
            width: 20px;
            height: 20px;
        }
        
        .distance-slider {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .slider-label {
            min-width: 120px;
            color: #b3c7ff;
        }
        
        .slider {
            flex: 1;
            -webkit-appearance: none;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6a8aff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(106, 138, 255, 0.5);
        }
        
        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-panel h3 {
            color: #ff9e7d;
            margin-bottom: 10px;
        }
        
        .info-panel p {
            color: #b3c7ff;
            line-height: 1.5;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 30px;
            color: #b3c7ff;
            font-size: 0.9rem;
        }
        
        .author {
            margin-top: 5px;
            font-size: 0.8rem;
        }
        
        .note-text {
            font-size: 0.8rem;
            color: #ff9e7d;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .orbital-diagrams {
                flex-direction: column;
                gap: 20px;
            }
            
            .orbital-diagram {
                width: 100%;
            }
            
            .hybridization-selector {
                flex-direction: column;
                align-items: center;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                flex-direction: column;
                width: 100%;
            }
            
            .distance-slider {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .slider-label {
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>碳原子杂化轨道成键模拟</h1>
            <div class="hybridization-selector">
                <div class="hybridization-option active" data-hybridization="none">不杂化</div>
                <div class="hybridization-option" data-hybridization="sp3">sp³杂化</div>
                <div class="hybridization-option" data-hybridization="sp2">sp²杂化</div>
                <div class="hybridization-option" data-hybridization="sp">sp杂化</div>
            </div>
        </header>
        
        <div class="main-content">
            <div class="orbital-diagrams">
                <div class="orbital-diagram" id="leftDiagram">
                    <h3>碳原子A</h3>
                    <div class="energy-levels" id="leftEnergyLevels">
                        <!-- 动态生成 -->
                    </div>
                    <div class="excitation-toggle">
                        <input type="checkbox" id="leftExcitation">
                        <label for="leftExcitation">激发</label>
                    </div>
                </div>
                
                <div class="visualization">
                    <div class="canvas-container">
                        <div id="threeCanvas"></div>
                        <div class="zoom-controls">
                            <button class="zoom-btn" id="zoomIn">+</button>
                            <button class="zoom-btn" id="zoomOut">-</button>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <div class="control-group">
                            <div class="control-item">
                                <input type="checkbox" id="showHydrogen">
                                <label for="showHydrogen">显示氢原子</label>
                            </div>
                            <div class="control-item">
                                <input type="checkbox" id="showElectrons">
                                <label for="showElectrons">显示轨道中的电子</label>
                            </div>
                            <div class="control-item">
                                <input type="checkbox" id="stopRotation">
                                <label for="stopRotation">停止旋转</label>
                            </div>
                        </div>
                        
                        <div class="distance-slider">
                            <div class="slider-label">原子间距</div>
                            <input type="range" min="0" max="100" value="100" class="slider" id="distanceSlider">
                        </div>
                    </div>
                    <!-- 添加注释 -->
                    <div class="note-text">*部分变化需要调整原子间距才会反映</div>
                </div>
                
                <div class="orbital-diagram" id="rightDiagram">
                    <h3>碳原子B</h3>
                    <div class="energy-levels" id="rightEnergyLevels">
                        <!-- 动态生成 -->
                    </div>
                    <div class="excitation-toggle">
                        <input type="checkbox" id="rightExcitation">
                        <label for="rightExcitation">激发</label>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3 id="infoTitle">不杂化轨道</h3>
            <p id="infoDescription">两个碳原子未杂化轨道，沿x轴方向彼此接近，观察p轨道重叠情况。</p>
        </div>
        
        <footer>
            <p>化学教学可视化工具 | 碳原子杂化轨道成键模拟</p>
            <p class="author">温州中学 刘晋阳</p>
        </footer>
    </div>

    <script>
        // Three.js 场景设置
        let scene, camera, renderer;
        let carbonAtom1, carbonAtom2;
        let orbitals1 = [], orbitals2 = [];
        let hydrogenAtoms = [];
        let electrons = [];
        let bonds = [];
        let piBonds = [];
        let animationId = null;
        
        // 杂化方式
        let currentHybridization = 'none';
        
        // 原子间距
        let atomDistance = 10;
        const minDistance = 1.2 + (10 - 1.2) * 0.45;
        const maxDistance = 10;
        
        // 3D旋转控制
        let rotationAngle = 0;
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let stopRotation = false;
        
        // 缩放控制
        let zoomLevel = 1.0;
        const zoomSpeed = 0.1;
        const minZoom = 0.5;
        const maxZoom = 2.0;
        
        // 轨道可见性控制
        let orbitalVisibility = {
            '2s_A': true, '2s_B': true,
            '2px_A': true, '2px_B': true,
            '2py_A': true, '2py_B': true,
            '2pz_A': true, '2pz_B': true,
            'sp3_1_A': true, 'sp3_1_B': true,
            'sp3_2_A': true, 'sp3_2_B': true,
            'sp3_3_A': true, 'sp3_3_B': true,
            'sp3_4_A': true, 'sp3_4_B': true,
            'sp2_1_A': true, 'sp2_1_B': true,
            'sp2_2_A': true, 'sp2_2_B': true,
            'sp2_3_A': true, 'sp2_3_B': true,
            'sp2_p_A': true, 'sp2_p_B': true,
            'sp_1_A': true, 'sp_1_B': true,
            'sp_2_A': true, 'sp_2_B': true,
            'sp_py_A': true, 'sp_py_B': true,
            'sp_pz_A': true, 'sp_pz_B': true
        };
        
        // 激发状态
        let leftExcitation = false;
        let rightExcitation = false;
        
        // px轨道重叠阈值 - 修改为6.77
        const pxOverlapThreshold = 6.77;
        
        // 存储氢原子在阈值位置的坐标
        let hydrogenFixedPositions = {
            left: null,
            right: null
        };

        // 初始化Three.js场景
        function initThreeJS() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // 创建相机
            const container = document.getElementById('threeCanvas');
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            // 设置初始视角：斜上方俯视
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);
            
            // 添加坐标轴
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // 初始化原子和轨道
            initAtomsAndOrbitals();
            
            // 设置鼠标控制
            setupMouseControls();
            
            // 设置缩放控制
            setupZoomControls();
            
            // 开始动画循环
            animate();
            
            // 窗口大小调整事件
            window.addEventListener('resize', onWindowResize);
        }
        
        // 设置鼠标控制
        function setupMouseControls() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                rotationAngle += deltaX * 0.01;
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
        }
        
        // 设置缩放控制
        function setupZoomControls() {
            const zoomInBtn = document.getElementById('zoomIn');
            const zoomOutBtn = document.getElementById('zoomOut');
            
            zoomInBtn.addEventListener('click', () => {
                zoomLevel = Math.min(maxZoom, zoomLevel + zoomSpeed);
                updateCameraZoom();
            });
            
            zoomOutBtn.addEventListener('click', () => {
                zoomLevel = Math.max(minZoom, zoomLevel - zoomSpeed);
                updateCameraZoom();
            });
        }
        
        // 更新相机缩放
        function updateCameraZoom() {
            // 保持相机位置不变，只调整视野
            camera.fov = 75 / zoomLevel;
            camera.updateProjectionMatrix();
        }
        
        // 初始化原子和轨道
        function initAtomsAndOrbitals() {
            // 创建碳原子
            const carbonGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const carbonMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff7e5f,
                shininess: 100,
                transparent: true,
                opacity: 0.8
            });
            
            carbonAtom1 = new THREE.Mesh(carbonGeometry, carbonMaterial);
            carbonAtom1.position.set(-atomDistance/2, 0, 0);
            scene.add(carbonAtom1);
            
            carbonAtom2 = new THREE.Mesh(carbonGeometry, carbonMaterial);
            carbonAtom2.position.set(atomDistance/2, 0, 0);
            scene.add(carbonAtom2);
            
            // 更新轨道
            updateOrbitals();
        }
        
        // 创建s轨道
        function createSOrbital(position, color, scale = 1.0, orbitalId = null) {
            const geometry = new THREE.SphereGeometry(1.5 * scale, 32, 32);
            
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const orbital = new THREE.Mesh(geometry, material);
            orbital.position.copy(position);
            if (orbitalId) orbital.userData.orbitalId = orbitalId;
            
            scene.add(orbital);
            
            return orbital;
        }
        
        // 创建p轨道
        function createPOrbital(position, direction, color, scale = 1.0, orbitalId = null) {
            const geometry = new THREE.SphereGeometry(0.6, 16, 16);
            
            // 调整p轨道形状
            const scaleX = direction.x !== 0 ? 2.5 * scale : 1.8 * scale;
            const scaleY = direction.y !== 0 ? 2.5 * scale : 1.8 * scale;
            const scaleZ = direction.z !== 0 ? 2.5 * scale : 1.8 * scale;
            
            geometry.scale(scaleX, scaleY, scaleZ);
            
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const orbital1 = new THREE.Mesh(geometry, material);
            orbital1.position.copy(position.clone().add(direction.clone().multiplyScalar(2.5 * scale)));
            if (orbitalId) orbital1.userData.orbitalId = orbitalId + '_1';
            
            const orbital2 = new THREE.Mesh(geometry, material);
            orbital2.position.copy(position.clone().add(direction.clone().multiplyScalar(-2.5 * scale)));
            if (orbitalId) orbital2.userData.orbitalId = orbitalId + '_2';
            
            scene.add(orbital1);
            scene.add(orbital2);
            
            return [orbital1, orbital2];
        }
        
        // 创建杂化轨道
        function createHybridOrbital(position, direction, color, scale = 1.0, orbitalId = null) {
            const geometry = new THREE.SphereGeometry(0.6, 16, 16);
            geometry.scale(2.2 * scale, 2.2 * scale, 2.8 * scale);
            
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const orbital = new THREE.Mesh(geometry, material);
            orbital.position.copy(position.clone().add(direction.clone().multiplyScalar(2.5 * scale)));
            if (orbitalId) orbital.userData.orbitalId = orbitalId;
            
            // 旋转轨道使其指向正确方向
            orbital.lookAt(position);
            
            scene.add(orbital);
            
            return orbital;
        }
        
        // 创建派键轨道
        function createPiBond(position, direction, color, scale = 1.0) {
            const geometry = new THREE.SphereGeometry(0.6, 16, 16);
            
            // 派键轨道形状：瘦长椭球体，长轴平行于x轴
            const scaleX = 4.5 * scale;
            const scaleY = 2.0 * scale;
            const scaleZ = 2.0 * scale;
            
            geometry.scale(scaleX, scaleY, scaleZ);
            
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const orbital = new THREE.Mesh(geometry, material);
            orbital.position.copy(position);
            
            scene.add(orbital);
            
            return orbital;
        }
        
        // 创建电子
        function createElectron(position, direction, spin, orbitalId = null) {
            // 创建箭杆（圆柱体）
            const cylinderGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
            const cylinderMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffff00,
                shininess: 100
            });
            
            const arrowShaft = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            
            // 创建箭头（圆锥体）
            const coneGeometry = new THREE.ConeGeometry(0.15, 0.3, 8);
            const coneMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffff00,
                shininess: 100
            });
            
            const arrowHead = new THREE.Mesh(coneGeometry, coneMaterial);
            arrowHead.position.y = 0.4;
            
            // 创建组来组合箭杆和箭头
            const electron = new THREE.Group();
            electron.add(arrowShaft);
            electron.add(arrowHead);
            
            electron.position.copy(position);
            
            // 所有电子朝向为绝对方向，与绿色坐标轴平行
            electron.lookAt(position.clone().add(new THREE.Vector3(0, 1, 0)));
            
            // 所有电子向上旋转90度
            electron.rotateX(Math.PI / 2);
            
            // 设置电子自旋方向
            if (spin === 'down') {
                electron.rotateZ(Math.PI);
            }
            
            if (orbitalId) electron.userData.orbitalId = orbitalId;
            
            scene.add(electron);
            return electron;
        }
        
        // 更新轨道显示
        function updateOrbitals() {
            // 清除现有轨道
            orbitals1.forEach(orbital => scene.remove(orbital));
            orbitals2.forEach(orbital => scene.remove(orbital));
            orbitals1 = [];
            orbitals2 = [];
            
            // 清除氢原子和化学键
            hydrogenAtoms.forEach(atom => scene.remove(atom));
            hydrogenAtoms = [];
            bonds.forEach(bond => scene.remove(bond));
            bonds = [];
            
            // 清除电子
            electrons.forEach(electron => scene.remove(electron));
            electrons = [];
            
            // 清除派键
            piBonds.forEach(bond => scene.remove(bond));
            piBonds = [];
            
            // 根据当前杂化方式创建轨道
            switch(currentHybridization) {
                case 'none':
                    createUnhybridizedOrbitals();
                    break;
                case 'sp3':
                    createSp3HybridizedOrbitals();
                    break;
                case 'sp2':
                    createSp2HybridizedOrbitals();
                    break;
                case 'sp':
                    createSpHybridizedOrbitals();
                    break;
            }
            
            // 更新轨道可见性
            updateOrbitalVisibility();
            
            // 更新氢原子显示
            updateHydrogenAtoms();
            
            // 更新轨道图
            updateOrbitalDiagrams();
            
            // 更新电子显示
            updateElectrons();
            
            // 更新派键显示
            updatePiBonds();
        }
        
        // 创建未杂化轨道
        function createUnhybridizedOrbitals() {
            // 创建s轨道
            const sOrbital1 = createSOrbital(carbonAtom1.position, 0x6a8aff, 1.0, '2s_A');
            orbitals1.push(sOrbital1);
            
            const sOrbital2 = createSOrbital(carbonAtom2.position, 0x6a8aff, 1.0, '2s_B');
            orbitals2.push(sOrbital2);
            
            // p轨道方向
            const directions = [
                new THREE.Vector3(1, 0, 0),  // p_x
                new THREE.Vector3(0, 1, 0),  // p_y
                new THREE.Vector3(0, 0, 1)   // p_z
            ];
            
            // 轨道颜色
            const colors = [0xff0000, 0x00ff00, 0x0000ff];
            const orbitalIds = ['2px', '2py', '2pz'];
            
            // 创建碳原子1的p轨道
            directions.forEach((dir, index) => {
                const newOrbitals = createPOrbital(carbonAtom1.position, dir, colors[index], 1.0, orbitalIds[index] + '_A');
                orbitals1.push(...newOrbitals);
            });
            
            // 创建碳原子2的p轨道
            directions.forEach((dir, index) => {
                const newOrbitals = createPOrbital(carbonAtom2.position, dir, colors[index], 1.0, orbitalIds[index] + '_B');
                orbitals2.push(...newOrbitals);
            });
            
            // 隐藏碳原子
            carbonAtom1.visible = false;
            carbonAtom2.visible = false;
        }
        
        // 创建sp³杂化轨道
        function createSp3HybridizedOrbitals() {
            // 四个sp³杂化轨道方向（正四面体）
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1/3, 2*Math.sqrt(2)/3, 0),
                new THREE.Vector3(-1/3, -Math.sqrt(2)/3, Math.sqrt(6)/3),
                new THREE.Vector3(-1/3, -Math.sqrt(2)/3, -Math.sqrt(6)/3)
            ];
            
            // 杂化轨道颜色
            const hybridColor = 0xff7e5f;
            
            // 创建碳原子1的杂化轨道
            directions.forEach((dir, index) => {
                const orbital = createHybridOrbital(carbonAtom1.position, dir, hybridColor, 1.0, `sp3_${index+1}_A`);
                orbitals1.push(orbital);
            });
            
            // 创建碳原子2的杂化轨道 - 修正方向使其对称
            directions.forEach((dir, index) => {
                const adjustedDir = new THREE.Vector3(-dir.x, dir.y, dir.z);
                const orbital = createHybridOrbital(carbonAtom2.position, adjustedDir, hybridColor, 1.0, `sp3_${index+1}_B`);
                orbitals2.push(orbital);
            });
            
            // 隐藏碳原子
            carbonAtom1.visible = false;
            carbonAtom2.visible = false;
        }
        
        // 创建sp²杂化轨道
        function createSp2HybridizedOrbitals() {
            // 三个sp²杂化轨道方向
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-0.5, 0, Math.sqrt(3)/2),
                new THREE.Vector3(-0.5, 0, -Math.sqrt(3)/2)
            ];
            
            // 杂化轨道颜色
            const hybridColor = 0xff7e5f;
            const pColor = 0x00ff00;
            
            // 创建碳原子1的杂化轨道
            directions.forEach((dir, index) => {
                const orbital = createHybridOrbital(carbonAtom1.position, dir, hybridColor, 1.0, `sp2_${index+1}_A`);
                orbitals1.push(orbital);
            });
            
            // 创建碳原子1的p轨道
            const pOrbitals = createPOrbital(carbonAtom1.position, new THREE.Vector3(0, 1, 0), pColor, 1.2, 'sp2_p_A');
            orbitals1.push(...pOrbitals);
            
            // 创建碳原子2的杂化轨道
            directions.forEach((dir, index) => {
                const adjustedDir = new THREE.Vector3(-dir.x, dir.y, dir.z);
                const orbital = createHybridOrbital(carbonAtom2.position, adjustedDir, hybridColor, 1.0, `sp2_${index+1}_B`);
                orbitals2.push(orbital);
            });
            
            // 创建碳原子2的p轨道
            const pOrbitals2 = createPOrbital(carbonAtom2.position, new THREE.Vector3(0, 1, 0), pColor, 1.2, 'sp2_p_B');
            orbitals2.push(...pOrbitals2);
            
            // 隐藏碳原子
            carbonAtom1.visible = false;
            carbonAtom2.visible = false;
        }
        
        // 创建sp杂化轨道
        function createSpHybridizedOrbitals() {
            // 两个sp杂化轨道方向
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1, 0, 0)
            ];
            
            // 杂化轨道颜色
            const hybridColor = 0xff7e5f;
            const pColor1 = 0x00ff00;
            const pColor2 = 0x0000ff;
            
            // 创建碳原子1的杂化轨道
            directions.forEach((dir, index) => {
                const orbital = createHybridOrbital(carbonAtom1.position, dir, hybridColor, 1.0, `sp_${index+1}_A`);
                orbitals1.push(orbital);
            });
            
            // 创建碳原子1的p轨道
            const pOrbitalsY = createPOrbital(carbonAtom1.position, new THREE.Vector3(0, 1, 0), pColor1, 1.2, 'sp_py_A');
            orbitals1.push(...pOrbitalsY);
            
            const pOrbitalsZ = createPOrbital(carbonAtom1.position, new THREE.Vector3(0, 0, 1), pColor2, 1.2, 'sp_pz_A');
            orbitals1.push(...pOrbitalsZ);
            
            // 创建碳原子2的杂化轨道
            directions.forEach((dir, index) => {
                const adjustedDir = new THREE.Vector3(-dir.x, dir.y, dir.z);
                const orbital = createHybridOrbital(carbonAtom2.position, adjustedDir, hybridColor, 1.0, `sp_${index+1}_B`);
                orbitals2.push(orbital);
            });
            
            // 创建碳原子2的p轨道
            const pOrbitalsY2 = createPOrbital(carbonAtom2.position, new THREE.Vector3(0, 1, 0), pColor1, 1.2, 'sp_py_B');
            orbitals2.push(...pOrbitalsY2);
            
            const pOrbitalsZ2 = createPOrbital(carbonAtom2.position, new THREE.Vector3(0, 0, 1), pColor2, 1.2, 'sp_pz_B');
            orbitals2.push(...pOrbitalsZ2);
            
            // 隐藏碳原子
            carbonAtom1.visible = false;
            carbonAtom2.visible = false;
        }
        
        // 更新轨道可见性
        function updateOrbitalVisibility() {
            // 更新所有轨道的透明度
            [...orbitals1, ...orbitals2].forEach(orbital => {
                if (orbital.userData.orbitalId) {
                    const orbitalId = orbital.userData.orbitalId;
                    // 提取基础轨道ID（去除_1或_2后缀）
                    let baseOrbitalId = orbitalId;
                    if (orbitalId.endsWith('_1') || orbitalId.endsWith('_2')) {
                        baseOrbitalId = orbitalId.substring(0, orbitalId.lastIndexOf('_'));
                    }
                    
                    if (orbitalVisibility[baseOrbitalId] !== undefined) {
                        orbital.material.opacity = orbitalVisibility[baseOrbitalId] ? 0.7 : 0.1;
                    }
                }
            });
        }
        
        // 更新氢原子显示
        function updateHydrogenAtoms() {
            const showHydrogen = document.getElementById('showHydrogen').checked;
            
            if (!showHydrogen) return;
            
            // 氢原子几何体
            const hydrogenGeometry = new THREE.SphereGeometry(1.0, 16, 16);
            const hydrogenMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x3498db,
                shininess: 100,
                transparent: true,
                opacity: 0.7
            });
            
            // 根据杂化方式创建氢原子
            switch(currentHybridization) {
                case 'none':
                    createHydrogenAtomsForUnhybridized(hydrogenGeometry, hydrogenMaterial);
                    break;
                case 'sp3':
                    createHydrogenAtomsForSp3(hydrogenGeometry, hydrogenMaterial);
                    break;
                case 'sp2':
                    createHydrogenAtomsForSp2(hydrogenGeometry, hydrogenMaterial);
                    break;
                case 'sp':
                    createHydrogenAtomsForSp(hydrogenGeometry, hydrogenMaterial);
                    break;
            }
        }
        
        // 为未杂化轨道创建氢原子
        function createHydrogenAtomsForUnhybridized(geometry, material) {
            // 只在x方向外侧添加氢原子
            const directions = [
                new THREE.Vector3(-1, 0, 0),  // 碳原子A的外侧
                new THREE.Vector3(1, 0, 0)    // 碳原子B的外侧
            ];
            
            // 计算px轨道是否重叠
            const pxOverlap = atomDistance <= pxOverlapThreshold;
            
            // 计算在阈值位置时氢原子的位置
            if (!hydrogenFixedPositions.left || !hydrogenFixedPositions.right) {
                const thresholdDistance = pxOverlapThreshold;
                hydrogenFixedPositions.left = new THREE.Vector3(-thresholdDistance/2 - 4, 0, 0);
                hydrogenFixedPositions.right = new THREE.Vector3(thresholdDistance/2 + 4, 0, 0);
            }
            
            directions.forEach((dir, index) => {
                const h = new THREE.Mesh(geometry, material);
                
                if (pxOverlap) {
                    // 如果原子间距小于等于6.77，氢原子位置固定
                    if (index === 0) {
                        h.position.copy(hydrogenFixedPositions.left);
                    } else {
                        h.position.copy(hydrogenFixedPositions.right);
                    }
                } else {
                    // 如果原子间距大于6.77，氢原子与px轨道重叠
                    if (index === 0) {
                        // 碳原子A的氢原子位于碳原子B的外侧
                        h.position.copy(carbonAtom2.position.clone().add(new THREE.Vector3(1, 0, 0).multiplyScalar(4)));
                    } else {
                        // 碳原子B的氢原子位于碳原子A的外侧
                        h.position.copy(carbonAtom1.position.clone().add(new THREE.Vector3(-1, 0, 0).multiplyScalar(4)));
                    }
                }
                
                scene.add(h);
                hydrogenAtoms.push(h);
            });
        }
        
        // 为sp³杂化轨道创建氢原子
        function createHydrogenAtomsForSp3(geometry, material) {
            // 四个sp³杂化轨道方向
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1/3, 2*Math.sqrt(2)/3, 0),
                new THREE.Vector3(-1/3, -Math.sqrt(2)/3, Math.sqrt(6)/3),
                new THREE.Vector3(-1/3, -Math.sqrt(2)/3, -Math.sqrt(6)/3)
            ];
            
            directions.forEach((dir, index) => {
                // 跳过指向对方的轨道（用于形成C-C键）
                if (index === 0) return;
                
                // 碳原子1的氢原子
                const h1 = new THREE.Mesh(geometry, material);
                h1.position.copy(carbonAtom1.position.clone().add(dir.clone().multiplyScalar(4)));
                scene.add(h1);
                hydrogenAtoms.push(h1);
                
                // 碳原子2的氢原子
                const adjustedDir = new THREE.Vector3(-dir.x, dir.y, dir.z);
                const h2 = new THREE.Mesh(geometry, material);
                h2.position.copy(carbonAtom2.position.clone().add(adjustedDir.clone().multiplyScalar(4)));
                scene.add(h2);
                hydrogenAtoms.push(h2);
            });
        }
        
        // 为sp²杂化轨道创建氢原子
        function createHydrogenAtomsForSp2(geometry, material) {
            // 三个sp²杂化轨道方向
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-0.5, 0, Math.sqrt(3)/2),
                new THREE.Vector3(-0.5, 0, -Math.sqrt(3)/2)
            ];
            
            directions.forEach((dir, index) => {
                // 跳过指向对方的轨道（用于形成C-C键）
                if (index === 0) return;
                
                // 碳原子1的氢原子
                const h1 = new THREE.Mesh(geometry, material);
                h1.position.copy(carbonAtom1.position.clone().add(dir.clone().multiplyScalar(4)));
                scene.add(h1);
                hydrogenAtoms.push(h1);
                
                // 碳原子2的氢原子
                const adjustedDir = new THREE.Vector3(-dir.x, dir.y, dir.z);
                const h2 = new THREE.Mesh(geometry, material);
                h2.position.copy(carbonAtom2.position.clone().add(adjustedDir.clone().multiplyScalar(4)));
                scene.add(h2);
                hydrogenAtoms.push(h2);
            });
        }
        
        // 为sp杂化轨道创建氢原子
        function createHydrogenAtomsForSp(geometry, material) {
            // 两个sp杂化轨道方向
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1, 0, 0)
            ];
            
            directions.forEach((dir, index) => {
                // 跳过指向对方的轨道（用于形成C-C键）
                if (index === 0) return;
                
                // 碳原子1的氢原子
                const h1 = new THREE.Mesh(geometry, material);
                h1.position.copy(carbonAtom1.position.clone().add(dir.clone().multiplyScalar(4)));
                scene.add(h1);
                hydrogenAtoms.push(h1);
                
                // 碳原子2的氢原子
                const adjustedDir = new THREE.Vector3(-dir.x, dir.y, dir.z);
                const h2 = new THREE.Mesh(geometry, material);
                h2.position.copy(carbonAtom2.position.clone().add(adjustedDir.clone().multiplyScalar(4)));
                scene.add(h2);
                hydrogenAtoms.push(h2);
            });
        }
        
        // 更新电子显示
        function updateElectrons() {
            const showElectrons = document.getElementById('showElectrons').checked;
            
            if (!showElectrons) return;
            
            // 根据当前杂化方式创建电子
            switch(currentHybridization) {
                case 'none':
                    createUnhybridizedElectrons();
                    break;
                case 'sp3':
                    createSp3Electrons();
                    break;
                case 'sp2':
                    createSp2Electrons();
                    break;
                case 'sp':
                    createSpElectrons();
                    break;
            }
        }
        
        // 创建未杂化电子
        function createUnhybridizedElectrons() {
            const excitationA = leftExcitation;
            const excitationB = rightExcitation;
            
            // 氢原子电子（如果显示氢原子）
            if (document.getElementById('showHydrogen').checked) {
                hydrogenAtoms.forEach((atom, index) => {
                    electrons.push(createElectron(
                        atom.position.clone(),
                        new THREE.Vector3(0, 1, 0),
                        'down',
                        `h_${index}`
                    ));
                });
            }
            
            // 碳原子A的电子
            // 2s轨道
            if (!excitationA) {
                // 基态：2s轨道有两个电子（自旋相反）
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(-0.3, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    '2s_A_1'
                ));
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(0.3, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    '2s_A_2'
                ));
            } else {
                // 激发态：2s轨道只有一个电子
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(0, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    '2s_A_1'
                ));
            }
            
            // 2px轨道 - 一个电子
            const pxOverlap = atomDistance <= pxOverlapThreshold;
            
            if (pxOverlap) {
                // 当px轨道重叠时，电子出现在靠近椭球长轴中心的位置
                // 修改：让电子更靠近椭球长轴的中心
                const electronOffset = 2.0; // 减小偏移量，让电子更靠近中心
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(electronOffset, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    '2px_A_1'
                ));
            } else {
                // 当px轨道未重叠时，电子出现在离H近的px椭球体内，方向为正
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(-2.5, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    '2px_A_1'
                ));
            }
            
            // 2py轨道 - 一个电子
            if (!excitationA) {
                // 基态：2py轨道有一个电子
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(0, 2.5, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    '2py_A_1'
                ));
            } else {
                // 激发态：2py轨道有一个电子
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(0, 2.5, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    '2py_A_1'
                ));
            }
            
            // 2pz轨道 - 激发态时2pz轨道有电子
            if (excitationA) {
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(0, 0, 2.5)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    '2pz_A_1'
                ));
            }
            
            // 碳原子B的电子
            // 2s轨道
            if (!excitationB) {
                // 基态：2s轨道有两个电子（自旋相反）
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(-0.3, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    '2s_B_1'
                ));
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(0.3, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    '2s_B_2'
                ));
            } else {
                // 激发态：2s轨道只有一个电子
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(0, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    '2s_B_1'
                ));
            }
            
            // 2px轨道 - 一个电子
            if (pxOverlap) {
                // 当px轨道重叠时，电子出现在靠近椭球长轴中心的位置
                // 修改：让电子更靠近椭球长轴的中心
                const electronOffset = 2.0; // 减小偏移量，让电子更靠近中心
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(-electronOffset, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    '2px_B_1'
                ));
            } else {
                // 当px轨道未重叠时，电子出现在离H近的px椭球体内，方向为正
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(2.5, 0, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    '2px_B_1'
                ));
            }
            
            // 2py轨道 - 一个电子
            if (!excitationB) {
                // 基态：2py轨道有一个电子
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(0, 2.5, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    '2py_B_1'
                ));
            } else {
                // 激发态：2py轨道有一个电子
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(0, 2.5, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    '2py_B_1'
                ));
            }
            
            // 2pz轨道 - 激发态时2pz轨道有电子
            if (excitationB) {
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(0, 0, 2.5)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    '2pz_B_1'
                ));
            }
        }
        
        // 创建sp³杂化电子
        function createSp3Electrons() {
            const excitationA = leftExcitation;
            const excitationB = rightExcitation;
            
            // 氢原子电子（如果显示氢原子）
            if (document.getElementById('showHydrogen').checked) {
                hydrogenAtoms.forEach((atom, index) => {
                    electrons.push(createElectron(
                        atom.position.clone(),
                        new THREE.Vector3(0, 1, 0),
                        'down',
                        `h_${index}`
                    ));
                });
            }
            
            // 碳原子A的电子
            const sp3Directions1 = [
                new THREE.Vector3(1, 0, 0),  // x方向
                new THREE.Vector3(-1/3, 2*Math.sqrt(2)/3, 0),
                new THREE.Vector3(-1/3, -Math.sqrt(2)/3, Math.sqrt(6)/3),
                new THREE.Vector3(-1/3, -Math.sqrt(2)/3, -Math.sqrt(6)/3)
            ];
            
            sp3Directions1.forEach((dir, index) => {
                // 只有x方向的电子方向相反，其它都朝上
                const spin = (index === 0) ? (excitationA ? 'up' : 'up') : 'up';
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(dir.clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    spin,
                    `sp3_${index+1}_A`
                ));
            });
            
            // 碳原子B的电子
            const sp3Directions2 = [
                new THREE.Vector3(-1, 0, 0),  // x方向
                new THREE.Vector3(1/3, 2*Math.sqrt(2)/3, 0),
                new THREE.Vector3(1/3, -Math.sqrt(2)/3, Math.sqrt(6)/3),
                new THREE.Vector3(1/3, -Math.sqrt(2)/3, -Math.sqrt(6)/3)
            ];
            
            sp3Directions2.forEach((dir, index) => {
                // 只有x方向的电子方向相反，其它都朝上
                const spin = (index === 0) ? (excitationB ? 'down' : 'down') : 'up';
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(dir.clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    spin,
                    `sp3_${index+1}_B`
                ));
            });
        }
        
        // 创建sp²杂化电子
        function createSp2Electrons() {
            const excitationA = leftExcitation;
            const excitationB = rightExcitation;
            
            // 氢原子电子（如果显示氢原子）
            if (document.getElementById('showHydrogen').checked) {
                hydrogenAtoms.forEach((atom, index) => {
                    electrons.push(createElectron(
                        atom.position.clone(),
                        new THREE.Vector3(0, 1, 0),
                        'down',
                        `h_${index}`
                    ));
                });
            }
            
            // 碳原子A的电子
            const sp2Directions1 = [
                new THREE.Vector3(1, 0, 0),  // x方向
                new THREE.Vector3(-0.5, 0, Math.sqrt(3)/2),
                new THREE.Vector3(-0.5, 0, -Math.sqrt(3)/2)
            ];
            
            // 基态：四个电子在sp2杂化轨道上
            if (!excitationA) {
                sp2Directions1.forEach((dir, index) => {
                    // 只有x方向的电子方向相反，其它都朝上
                    const spin = (index === 0) ? 'up' : 'up';
                    electrons.push(createElectron(
                        carbonAtom1.position.clone().add(dir.clone().multiplyScalar(1.5)),
                        new THREE.Vector3(0, 1, 0),
                        spin,
                        `sp2_${index+1}_A`
                    ));
                });
                
                // 第四个电子在第一个sp2轨道上（自旋相反）
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(sp2Directions1[0].clone().multiplyScalar(1.7)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    'sp2_1_A_2'
                ));
            } else {
                // 激发态：每个轨道一个电子
                sp2Directions1.forEach((dir, index) => {
                    // 只有x方向的电子方向相反，其它都朝上
                    const spin = (index === 0) ? 'up' : 'up';
                    electrons.push(createElectron(
                        carbonAtom1.position.clone().add(dir.clone().multiplyScalar(1.5)),
                        new THREE.Vector3(0, 1, 0),
                        spin,
                        `sp2_${index+1}_A`
                    ));
                });
                
                // p轨道电子
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(0, 2.5, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    'sp2_p_A'
                ));
            }
            
            // 碳原子B的电子
            const sp2Directions2 = [
                new THREE.Vector3(-1, 0, 0),  // x方向
                new THREE.Vector3(0.5, 0, Math.sqrt(3)/2),
                new THREE.Vector3(0.5, 0, -Math.sqrt(3)/2)
            ];
            
            // 基态：四个电子在sp2杂化轨道上
            if (!excitationB) {
                sp2Directions2.forEach((dir, index) => {
                    // 只有x方向的电子方向相反，其它都朝上
                    const spin = (index === 0) ? 'down' : 'up';
                    electrons.push(createElectron(
                        carbonAtom2.position.clone().add(dir.clone().multiplyScalar(1.5)),
                        new THREE.Vector3(0, 1, 0),
                        spin,
                        `sp2_${index+1}_B`
                    ));
                });
                
                // 第四个电子在第一个sp2轨道上（自旋相反）
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(sp2Directions2[0].clone().multiplyScalar(1.7)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    'sp2_1_B_2'
                ));
            } else {
                // 激发态：每个轨道一个电子
                sp2Directions2.forEach((dir, index) => {
                    // 只有x方向的电子方向相反，其它都朝上
                    const spin = (index === 0) ? 'down' : 'up';
                    electrons.push(createElectron(
                        carbonAtom2.position.clone().add(dir.clone().multiplyScalar(1.5)),
                        new THREE.Vector3(0, 1, 0),
                        spin,
                        `sp2_${index+1}_B`
                    ));
                });
                
                // p轨道电子
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(0, 2.5, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    'sp2_p_B'
                ));
            }
        }
        
        // 创建sp杂化电子
        function createSpElectrons() {
            const excitationA = leftExcitation;
            const excitationB = rightExcitation;
            
            // 氢原子电子（如果显示氢原子）
            if (document.getElementById('showHydrogen').checked) {
                hydrogenAtoms.forEach((atom, index) => {
                    electrons.push(createElectron(
                        atom.position.clone(),
                        new THREE.Vector3(0, 1, 0),
                        'down',
                        `h_${index}`
                    ));
                });
            }
            
            // 碳原子A的电子
            const spDirections1 = [
                new THREE.Vector3(1, 0, 0),  // 与H重叠的轨道
                new THREE.Vector3(-1, 0, 0)  // x方向（指向碳原子B）
            ];
            
            // 基态：四个电子在sp杂化轨道上
            if (!excitationA) {
                // 与H重叠的轨道电子方向为正
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(spDirections1[0].clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    'sp_1_A'
                ));
                
                // 与碳原子B重叠的轨道电子方向为正
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(spDirections1[1].clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    'sp_2_A'
                ));
                
                // 第三、四个电子在sp轨道上（自旋相反）
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(spDirections1[0].clone().multiplyScalar(1.7)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    'sp_1_A_2'
                ));
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(spDirections1[1].clone().multiplyScalar(1.7)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    'sp_2_A_2'
                ));
            } else {
                // 激发态：每个轨道一个电子
                // 与H重叠的轨道电子方向为正
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(spDirections1[0].clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    'sp_1_A'
                ));
                
                // 与碳原子B重叠的轨道电子方向为正
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(spDirections1[1].clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    'sp_2_A'
                ));
                
                // p轨道电子
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(0, 2.5, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    'sp_py_A'
                ));
                
                electrons.push(createElectron(
                    carbonAtom1.position.clone().add(new THREE.Vector3(0, 0, 2.5)),
                    new THREE.Vector3(0, 1, 0),
                    'up',
                    'sp_pz_A'
                ));
            }
            
            // 碳原子B的电子
            const spDirections2 = [
                new THREE.Vector3(-1, 0, 0),  // 与H重叠的轨道
                new THREE.Vector3(1, 0, 0)    // x方向（指向碳原子A）
            ];
            
            // 基态：四个电子在sp杂化轨道上
            if (!excitationB) {
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(spDirections2[0].clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    'down',  // 与氢原子电子方向相同
                    'sp_1_B'
                ));
                
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(spDirections2[1].clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    'up',  // 与碳原子A的对应电子方向相同
                    'sp_2_B'
                ));
                
                // 第三、四个电子在sp轨道上（自旋相反）
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(spDirections2[0].clone().multiplyScalar(1.7)),
                    new THREE.Vector3(0, 1, 0),
                    'up',  // 自旋相反
                    'sp_1_B_2'
                ));
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(spDirections2[1].clone().multiplyScalar(1.7)),
                    new THREE.Vector3(0, 1, 0),
                    'down',  // 自旋相反
                    'sp_2_B_2'
                ));
            } else {
                // 激发态：每个轨道一个电子
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(spDirections2[0].clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    'down',  // 与氢原子电子方向相同
                    'sp_1_B'
                ));
                
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(spDirections2[1].clone().multiplyScalar(1.5)),
                    new THREE.Vector3(0, 1, 0),
                    'up',  // 与碳原子A的对应电子方向相同
                    'sp_2_B'
                ));
                
                // p轨道电子
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(0, 2.5, 0)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    'sp_py_B'
                ));
                
                electrons.push(createElectron(
                    carbonAtom2.position.clone().add(new THREE.Vector3(0, 0, 2.5)),
                    new THREE.Vector3(0, 1, 0),
                    'down',
                    'sp_pz_B'
                ));
            }
        }
        
        // 更新派键显示
        function updatePiBonds() {
            // Π键仅在两原子均激发且距离最小时形成
            const minDistanceReached = atomDistance <= minDistance + 0.5;
            const bothExcited = leftExcitation && rightExcitation;
            
            if (bothExcited && minDistanceReached) {
                // 创建派键轨道
                if (currentHybridization === 'sp2') {
                    // sp2杂化：一个派键（来自py轨道）
                    const piBondPy1 = createPiBond(
                        new THREE.Vector3(0, 3.0, 0),
                        new THREE.Vector3(1, 0, 0),
                        0x00ff00,
                        1.0
                    );
                    piBonds.push(piBondPy1);
                    
                    const piBondPy2 = createPiBond(
                        new THREE.Vector3(0, -3.0, 0),
                        new THREE.Vector3(1, 0, 0),
                        0x00ff00,
                        1.0
                    );
                    piBonds.push(piBondPy2);
                    
                    // 隐藏原来的p轨道
                    hidePOrbitalsForPiBond();
                    
                    // 隐藏p轨道中的电子
                    hidePElectronsForPiBond();
                    
                    // 仅在显示电子时创建Π键电子
                    const showElectrons = document.getElementById('showElectrons').checked;
                    if (showElectrons) {
                        electrons.push(createElectron(
                            new THREE.Vector3(0, 3.0, 0.5),
                            new THREE.Vector3(0, 1, 0),
                            'up',
                            'pi_bond_1'
                        ));
                        electrons.push(createElectron(
                            new THREE.Vector3(0, 3.0, -0.5),
                            new THREE.Vector3(0, 1, 0),
                            'down',
                            'pi_bond_2'
                        ));
                    }
                } else if (currentHybridization === 'sp') {
                    // sp杂化：两个派键（来自py和pz轨道）
                    const piBondPy1 = createPiBond(
                        new THREE.Vector3(0, 3.0, 0),
                        new THREE.Vector3(1, 0, 0),
                        0x00ff00,
                        1.0
                    );
                    piBonds.push(piBondPy1);
                    
                    const piBondPy2 = createPiBond(
                        new THREE.Vector3(0, -3.0, 0),
                        new THREE.Vector3(1, 0, 0),
                        0x00ff00,
                        1.0
                    );
                    piBonds.push(piBondPy2);
                    
                    const piBondPz1 = createPiBond(
                        new THREE.Vector3(0, 0, 3.0),
                        new THREE.Vector3(1, 0, 0),
                        0x0000ff,
                        1.0
                    );
                    piBonds.push(piBondPz1);
                    
                    const piBondPz2 = createPiBond(
                        new THREE.Vector3(0, 0, -3.0),
                        new THREE.Vector3(1, 0, 0),
                        0x0000ff,
                        1.0
                    );
                    piBonds.push(piBondPz2);
                    
                    // 隐藏原来的p轨道
                    hidePOrbitalsForPiBond();
                    
                    // 隐藏p轨道中的电子
                    hidePElectronsForPiBond();
                    
                    // 仅在显示电子时创建Π键电子
                    const showElectrons = document.getElementById('showElectrons').checked;
                    if (showElectrons) {
                        // y方向派键电子
                        electrons.push(createElectron(
                            new THREE.Vector3(0, 3.0, 0.5),
                            new THREE.Vector3(0, 1, 0),
                            'up',
                            'pi_bond_py_1'
                        ));
                        electrons.push(createElectron(
                            new THREE.Vector3(0, 3.0, -0.5),
                            new THREE.Vector3(0, 1, 0),
                            'down',
                            'pi_bond_py_2'
                        ));
                        
                        // z方向派键电子并排放置（连线与x方向平行）
                        electrons.push(createElectron(
                            new THREE.Vector3(0.5, 0, 3.0),  // 改为x方向偏移
                            new THREE.Vector3(0, 1, 0),
                            'up',
                            'pi_bond_pz_1'
                        ));
                        electrons.push(createElectron(
                            new THREE.Vector3(-0.5, 0, 3.0),  // 改为x方向偏移
                            new THREE.Vector3(0, 1, 0),
                            'down',
                            'pi_bond_pz_2'
                        ));
                    }
                } else if (currentHybridization === 'none') {
                    // 不杂化时也增加y和z方向的Π键
                    const piBondPy1 = createPiBond(
                        new THREE.Vector3(0, 3.0, 0),
                        new THREE.Vector3(1, 0, 0),
                        0x00ff00,
                        1.0
                    );
                    piBonds.push(piBondPy1);
                    
                    const piBondPy2 = createPiBond(
                        new THREE.Vector3(0, -3.0, 0),
                        new THREE.Vector3(1, 0, 0),
                        0x00ff00,
                        1.0
                    );
                    piBonds.push(piBondPy2);
                    
                    const piBondPz1 = createPiBond(
                        new THREE.Vector3(0, 0, 3.0),
                        new THREE.Vector3(1, 0, 0),
                        0x0000ff,
                        1.0
                    );
                    piBonds.push(piBondPz1);
                    
                    const piBondPz2 = createPiBond(
                        new THREE.Vector3(0, 0, -3.0),
                        new THREE.Vector3(1, 0, 0),
                        0x0000ff,
                        1.0
                    );
                    piBonds.push(piBondPz2);
                    
                    // 隐藏原来的p轨道
                    hidePOrbitalsForPiBond();
                    
                    // 隐藏p轨道中的电子
                    hidePElectronsForPiBond();
                    
                    // 仅在显示电子时创建Π键电子
                    const showElectrons = document.getElementById('showElectrons').checked;
                    if (showElectrons) {
                        // y方向派键电子
                        electrons.push(createElectron(
                            new THREE.Vector3(0, 3.0, 0.5),
                            new THREE.Vector3(0, 1, 0),
                            'up',
                            'pi_bond_py_1'
                        ));
                        electrons.push(createElectron(
                            new THREE.Vector3(0, 3.0, -0.5),
                            new THREE.Vector3(0, 1, 0),
                            'down',
                            'pi_bond_py_2'
                        ));
                        
                        // z方向派键电子并排放置（连线与x方向平行）
                        electrons.push(createElectron(
                            new THREE.Vector3(0.5, 0, 3.0),
                            new THREE.Vector3(0, 1, 0),
                            'up',
                            'pi_bond_pz_1'
                        ));
                        electrons.push(createElectron(
                            new THREE.Vector3(-0.5, 0, 3.0),
                            new THREE.Vector3(0, 1, 0),
                            'down',
                            'pi_bond_pz_2'
                        ));
                    }
                }
            } else {
                // 恢复p轨道显示
                restorePOrbitals();
            }
        }
        
        // 形成Π键时隐藏原来的p轨道
        function hidePOrbitalsForPiBond() {
            orbitals1.forEach(orbital => {
                if (orbital.userData.orbitalId && 
                    (orbital.userData.orbitalId.includes('2py') || 
                     orbital.userData.orbitalId.includes('2pz') ||
                     orbital.userData.orbitalId.includes('sp2_p') ||
                     orbital.userData.orbitalId.includes('sp_py') || 
                     orbital.userData.orbitalId.includes('sp_pz'))) {
                    orbital.visible = false;
                }
            });
            orbitals2.forEach(orbital => {
                if (orbital.userData.orbitalId && 
                    (orbital.userData.orbitalId.includes('2py') || 
                     orbital.userData.orbitalId.includes('2pz') ||
                     orbital.userData.orbitalId.includes('sp2_p') ||
                     orbital.userData.orbitalId.includes('sp_py') || 
                     orbital.userData.orbitalId.includes('sp_pz'))) {
                    orbital.visible = false;
                }
            });
        }
        
        // 形成Π键时隐藏p轨道中的电子
        function hidePElectronsForPiBond() {
            electrons.forEach(electron => {
                if (electron.userData.orbitalId && 
                    (electron.userData.orbitalId.includes('2py') || 
                     electron.userData.orbitalId.includes('2pz') ||
                     electron.userData.orbitalId.includes('sp2_p') ||
                     electron.userData.orbitalId.includes('sp_py') || 
                     electron.userData.orbitalId.includes('sp_pz'))) {
                    electron.visible = false;
                }
            });
        }
        
        // 恢复p轨道显示
        function restorePOrbitals() {
            orbitals1.forEach(orbital => {
                if (orbital.userData.orbitalId) {
                    orbital.visible = true;
                }
            });
            orbitals2.forEach(orbital => {
                if (orbital.userData.orbitalId) {
                    orbital.visible = true;
                }
            });
            
            // 恢复电子显示
            electrons.forEach(electron => {
                electron.visible = true;
            });
        }
        
        // 更新原子位置
        function updateAtomPositions() {
            const sliderValue = document.getElementById('distanceSlider').value;
            atomDistance = minDistance + (maxDistance - minDistance) * (sliderValue / 100);
            
            carbonAtom1.position.set(-atomDistance/2, 0, 0);
            carbonAtom2.position.set(atomDistance/2, 0, 0);
            
            // 更新轨道
            updateOrbitals();
        }
        
        // 更新轨道图
        function updateOrbitalDiagrams() {
            const leftEnergyLevels = document.getElementById('leftEnergyLevels');
            const rightEnergyLevels = document.getElementById('rightEnergyLevels');
            
            leftEnergyLevels.innerHTML = '';
            rightEnergyLevels.innerHTML = '';
            
            switch(currentHybridization) {
                case 'none':
                    createUnhybridizedDiagram(leftEnergyLevels, 'left');
                    createUnhybridizedDiagram(rightEnergyLevels, 'right');
                    break;
                case 'sp3':
                    createSp3Diagram(leftEnergyLevels, 'left');
                    createSp3Diagram(rightEnergyLevels, 'right');
                    break;
                case 'sp2':
                    createSp2Diagram(leftEnergyLevels, 'left');
                    createSp2Diagram(rightEnergyLevels, 'right');
                    break;
                case 'sp':
                    createSpDiagram(leftEnergyLevels, 'left');
                    createSpDiagram(rightEnergyLevels, 'right');
                    break;
            }
        }
        
        // 创建未杂化轨道图
        function createUnhybridizedDiagram(container, side) {
            const excitation = side === 'left' ? leftExcitation : rightExcitation;
            
            // 2p轨道
            const pLevel = document.createElement('div');
            pLevel.className = 'energy-level';
            
            const pRow = document.createElement('div');
            pRow.className = 'orbital-row';
            
            const pOrbitals = [
                { id: '2pz', label: '2p_z', color: '#0000ff' },
                { id: '2py', label: '2p_y', color: '#00ff00' },
                { id: '2px', label: '2p_x', color: '#ff0000' }
            ];
            
            pOrbitals.forEach(orbital => {
                const circle = document.createElement('div');
                circle.className = 'orbital-circle';
                circle.style.borderColor = orbital.color;
                
                // 电子排布
                if (excitation) {
                    // 激发态：每个轨道一个电子
                    const electronEl = document.createElement('div');
                    electronEl.className = 'electron up';
                    electronEl.textContent = '↑';
                    circle.appendChild(electronEl);
                } else {
                    // 基态：2p_x和2p_y各有一个电子，2p_z为空
                    if (orbital.id === '2px' || orbital.id === '2py') {
                        const electronEl = document.createElement('div');
                        electronEl.className = 'electron up';
                        electronEl.textContent = '↑';
                        circle.appendChild(electronEl);
                    }
                }
                
                const toggle = document.createElement('input');
                toggle.type = 'checkbox';
                toggle.className = 'orbital-toggle';
                toggle.checked = orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')];
                toggle.addEventListener('change', (e) => {
                    orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')] = e.target.checked;
                    updateOrbitalVisibility();
                });
                
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'energy-level';
                orbitalContainer.style.alignItems = 'center';
                
                orbitalContainer.appendChild(circle);
                orbitalContainer.appendChild(toggle);
                
                pRow.appendChild(orbitalContainer);
            });
            
            pLevel.appendChild(pRow);
            
            const pLabel = document.createElement('div');
            pLabel.className = 'orbital-label';
            pLabel.textContent = '2p轨道';
            pLevel.appendChild(pLabel);
            
            container.appendChild(pLevel);
            
            // 2s轨道
            const sLevel = document.createElement('div');
            sLevel.className = 'energy-level';
            
            const sRow = document.createElement('div');
            sRow.className = 'orbital-row';
            
            const sCircle = document.createElement('div');
            sCircle.className = 'orbital-circle';
            sCircle.style.borderColor = '#6a8aff';
            
            // 2s轨道有两个电子
            if (excitation) {
                // 激发态：2s轨道只有一个电子
                const electronEl = document.createElement('div');
                electronEl.className = 'electron up';
                electronEl.textContent = '↑';
                sCircle.appendChild(electronEl);
            } else {
                // 基态：2s轨道有两个电子（自旋相反）
                const electron1 = document.createElement('div');
                electron1.className = 'electron up';
                electron1.textContent = '↑';
                electron1.style.position = 'absolute';
                electron1.style.left = '5px';
                sCircle.appendChild(electron1);
                
                const electron2 = document.createElement('div');
                electron2.className = 'electron down';
                electron2.textContent = '↑';
                electron2.style.position = 'absolute';
                electron2.style.left = '15px';
                sCircle.appendChild(electron2);
            }
            
            const sToggle = document.createElement('input');
            sToggle.type = 'checkbox';
            sToggle.className = 'orbital-toggle';
            sToggle.checked = orbitalVisibility['2s_' + (side === 'left' ? 'A' : 'B')];
            sToggle.addEventListener('change', (e) => {
                orbitalVisibility['2s_' + (side === 'left' ? 'A' : 'B')] = e.target.checked;
                updateOrbitalVisibility();
            });
            
            sRow.appendChild(sCircle);
            sRow.appendChild(sToggle);
            
            sLevel.appendChild(sRow);
            
            const sLabel = document.createElement('div');
            sLabel.className = 'orbital-label';
            sLabel.textContent = '2s轨道';
            sLevel.appendChild(sLabel);
            
            container.appendChild(sLevel);
        }
        
        // 创建sp³杂化轨道图
        function createSp3Diagram(container, side) {
            const excitation = side === 'left' ? leftExcitation : rightExcitation;
            
            const level = document.createElement('div');
            level.className = 'energy-level';
            
            const row = document.createElement('div');
            row.className = 'orbital-row';
            
            const orbitals = [
                { id: 'sp3_1', label: 'sp³', color: '#ff7e5f' },
                { id: 'sp3_2', label: 'sp³', color: '#ff7e5f' },
                { id: 'sp3_3', label: 'sp³', color: '#ff7e5f' },
                { id: 'sp3_4', label: 'sp³', color: '#ff7e5f' }
            ];
            
            orbitals.forEach(orbital => {
                const circle = document.createElement('div');
                circle.className = 'orbital-circle';
                circle.style.borderColor = orbital.color;
                
                // 每个sp³轨道有一个电子
                const electronEl = document.createElement('div');
                electronEl.className = 'electron up';
                electronEl.textContent = '↑';
                circle.appendChild(electronEl);
                
                const toggle = document.createElement('input');
                toggle.type = 'checkbox';
                toggle.className = 'orbital-toggle';
                toggle.checked = orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')];
                toggle.addEventListener('change', (e) => {
                    orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')] = e.target.checked;
                    updateOrbitalVisibility();
                });
                
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'energy-level';
                orbitalContainer.style.alignItems = 'center';
                
                orbitalContainer.appendChild(circle);
                orbitalContainer.appendChild(toggle);
                
                row.appendChild(orbitalContainer);
            });
            
            level.appendChild(row);
            
            const label = document.createElement('div');
            label.className = 'orbital-label';
            label.textContent = 'sp³杂化轨道';
            level.appendChild(label);
            
            container.appendChild(level);
        }
        
        // 创建sp²杂化轨道图
        function createSp2Diagram(container, side) {
            const excitation = side === 'left' ? leftExcitation : rightExcitation;
            
            // p轨道
            const pLevel = document.createElement('div');
            pLevel.className = 'energy-level';
            
            const pRow = document.createElement('div');
            pRow.className = 'orbital-row';
            
            const pCircle = document.createElement('div');
            pCircle.className = 'orbital-circle';
            pCircle.style.borderColor = '#00ff00';
            
            // 激发态：p轨道有一个电子
            if (excitation) {
                const pElectron = document.createElement('div');
                pElectron.className = 'electron up';
                pElectron.textContent = '↑';
                pCircle.appendChild(pElectron);
            }
            
            const pToggle = document.createElement('input');
            pToggle.type = 'checkbox';
            pToggle.className = 'orbital-toggle';
            pToggle.checked = orbitalVisibility['sp2_p_' + (side === 'left' ? 'A' : 'B')];
            pToggle.addEventListener('change', (e) => {
                orbitalVisibility['sp2_p_' + (side === 'left' ? 'A' : 'B')] = e.target.checked;
                updateOrbitalVisibility();
            });
            
            pRow.appendChild(pCircle);
            pRow.appendChild(pToggle);
            
            pLevel.appendChild(pRow);
            
            const pLabel = document.createElement('div');
            pLabel.className = 'orbital-label';
            pLabel.textContent = '2p_y轨道';
            pLevel.appendChild(pLabel);
            
            container.appendChild(pLevel);
            
            // sp²杂化轨道
            const sp2Level = document.createElement('div');
            sp2Level.className = 'energy-level';
            
            const sp2Row = document.createElement('div');
            sp2Row.className = 'orbital-row';
            
            const sp2Orbitals = [
                { id: 'sp2_1', label: 'sp²', color: '#ff7e5f' },
                { id: 'sp2_2', label: 'sp²', color: '#ff7e5f' },
                { id: 'sp2_3', label: 'sp²', color: '#ff7e5f' }
            ];
            
            sp2Orbitals.forEach(orbital => {
                const circle = document.createElement('div');
                circle.className = 'orbital-circle';
                circle.style.borderColor = orbital.color;
                
                // 基态：四个电子在sp2杂化轨道上
                if (!excitation) {
                    // 每个sp²轨道有一个电子
                    const electronEl = document.createElement('div');
                    electronEl.className = 'electron up';
                    electronEl.textContent = '↑';
                    circle.appendChild(electronEl);
                    
                    // 第一个轨道有第二个电子（自旋相反）
                    if (orbital.id === 'sp2_1') {
                        const electron2 = document.createElement('div');
                        electron2.className = 'electron down';
                        electron2.textContent = '↑';
                        electron2.style.position = 'absolute';
                        electron2.style.left = '15px';
                        circle.appendChild(electron2);
                    }
                } else {
                    // 激发态：每个轨道一个电子
                    const electronEl = document.createElement('div');
                    electronEl.className = 'electron up';
                    electronEl.textContent = '↑';
                    circle.appendChild(electronEl);
                }
                
                const toggle = document.createElement('input');
                toggle.type = 'checkbox';
                toggle.className = 'orbital-toggle';
                toggle.checked = orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')];
                toggle.addEventListener('change', (e) => {
                    orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')] = e.target.checked;
                    updateOrbitalVisibility();
                });
                
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'energy-level';
                orbitalContainer.style.alignItems = 'center';
                
                orbitalContainer.appendChild(circle);
                orbitalContainer.appendChild(toggle);
                
                sp2Row.appendChild(orbitalContainer);
            });
            
            sp2Level.appendChild(sp2Row);
            
            const sp2Label = document.createElement('div');
            sp2Label.className = 'orbital-label';
            sp2Label.textContent = 'sp²杂化轨道';
            sp2Level.appendChild(sp2Label);
            
            container.appendChild(sp2Level);
        }
        
        // 创建sp杂化轨道图
        function createSpDiagram(container, side) {
            const excitation = side === 'left' ? leftExcitation : rightExcitation;
            
            // p轨道
            const pLevel = document.createElement('div');
            pLevel.className = 'energy-level';
            
            const pRow = document.createElement('div');
            pRow.className = 'orbital-row';
            
            const pOrbitals = [
                { id: 'sp_py', label: '2p_y', color: '#00ff00' },
                { id: 'sp_pz', label: '2p_z', color: '#0000ff' }
            ];
            
            pOrbitals.forEach(orbital => {
                const circle = document.createElement('div');
                circle.className = 'orbital-circle';
                circle.style.borderColor = orbital.color;
                
                // 激发态：每个p轨道有一个电子
                if (excitation) {
                    const electronEl = document.createElement('div');
                    electronEl.className = 'electron up';
                    electronEl.textContent = '↑';
                    circle.appendChild(electronEl);
                }
                
                const toggle = document.createElement('input');
                toggle.type = 'checkbox';
                toggle.className = 'orbital-toggle';
                toggle.checked = orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')];
                toggle.addEventListener('change', (e) => {
                    orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')] = e.target.checked;
                    updateOrbitalVisibility();
                });
                
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'energy-level';
                orbitalContainer.style.alignItems = 'center';
                
                orbitalContainer.appendChild(circle);
                orbitalContainer.appendChild(toggle);
                
                pRow.appendChild(orbitalContainer);
            });
            
            pLevel.appendChild(pRow);
            
            const pLabel = document.createElement('div');
            pLabel.className = 'orbital-label';
            pLabel.textContent = 'p轨道';
            pLevel.appendChild(pLabel);
            
            container.appendChild(pLevel);
            
            // sp杂化轨道
            const spLevel = document.createElement('div');
            spLevel.className = 'energy-level';
            
            const spRow = document.createElement('div');
            spRow.className = 'orbital-row';
            
            const spOrbitals = [
                { id: 'sp_1', label: 'sp', color: '#ff7e5f' },
                { id: 'sp_2', label: 'sp', color: '#ff7e5f' }
            ];
            
            spOrbitals.forEach(orbital => {
                const circle = document.createElement('div');
                circle.className = 'orbital-circle';
                circle.style.borderColor = orbital.color;
                
                // 基态：四个电子在sp杂化轨道上
                if (!excitation) {
                    // 每个sp轨道有两个电子（自旋相反）
                    const electron1 = document.createElement('div');
                    electron1.className = 'electron up';
                    electron1.textContent = '↑';
                    electron1.style.position = 'absolute';
                    electron1.style.left = '5px';
                    circle.appendChild(electron1);
                    
                    const electron2 = document.createElement('div');
                    electron2.className = 'electron down';
                    electron2.textContent = '↑';
                    electron2.style.position = 'absolute';
                    electron2.style.left = '15px';
                    circle.appendChild(electron2);
                } else {
                    // 激发态：每个轨道一个电子
                    const electronEl = document.createElement('div');
                    electronEl.className = 'electron up';
                    electronEl.textContent = '↑';
                    circle.appendChild(electronEl);
                }
                
                const toggle = document.createElement('input');
                toggle.type = 'checkbox';
                toggle.className = 'orbital-toggle';
                toggle.checked = orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')];
                toggle.addEventListener('change', (e) => {
                    orbitalVisibility[orbital.id + '_' + (side === 'left' ? 'A' : 'B')] = e.target.checked;
                    updateOrbitalVisibility();
                });
                
                const orbitalContainer = document.createElement('div');
                orbitalContainer.className = 'energy-level';
                orbitalContainer.style.alignItems = 'center';
                
                orbitalContainer.appendChild(circle);
                orbitalContainer.appendChild(toggle);
                
                spRow.appendChild(orbitalContainer);
            });
            
            spLevel.appendChild(spRow);
            
            const spLabel = document.createElement('div');
            spLabel.className = 'orbital-label';
            spLabel.textContent = 'sp杂化轨道';
            spLevel.appendChild(spLabel);
            
            container.appendChild(spLevel);
        }
        
        // 动画循环
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // 自动旋转场景（如果没有鼠标控制且未停止旋转）
            if (!isMouseDown && !stopRotation) {
                rotationAngle += 0.005;
            }
            scene.rotation.y = rotationAngle;
            
            renderer.render(scene, camera);
        }
        
        // 窗口大小调整
        function onWindowResize() {
            const container = document.getElementById('threeCanvas');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // 更新信息面板
        function updateInfoPanel() {
            const infoTitle = document.getElementById('infoTitle');
            const infoDescription = document.getElementById('infoDescription');
            
            switch(currentHybridization) {
                case 'none':
                    infoTitle.textContent = '不杂化轨道';
                    infoDescription.textContent = '两个碳原子未杂化轨道，沿x轴方向彼此接近，观察p轨道重叠情况。';
                    break;
                case 'sp3':
                    infoTitle.textContent = 'sp³杂化轨道（乙烷模型）';
                    infoDescription.textContent = '每个碳原子形成四个sp³杂化轨道，呈正四面体结构。两个碳原子沿x轴接近，观察sp³轨道头碰头重叠形成C-C σ键。';
                    break;
                case 'sp2':
                    infoTitle.textContent = 'sp²杂化轨道（乙烯模型）';
                    infoDescription.textContent = '每个碳原子形成三个sp²杂化轨道（平面三角形）和一个垂直于平面的p轨道。两个碳原子沿x轴接近，观察sp²轨道头碰头重叠形成C-C σ键，以及p轨道肩并肩重叠形成π键。';
                    break;
                case 'sp':
                    infoTitle.textContent = 'sp杂化轨道（乙炔模型）';
                    infoDescription.textContent = '每个碳原子形成两个sp杂化轨道（直线型）和两个相互垂直的p轨道。两个碳原子沿x轴接近，观察sp轨道头碰头重叠形成C-C σ键，以及两组p轨道肩并肩重叠形成两个π键。';
                    break;
            }
        }
        
        // 初始化
        window.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            
            // 杂化方式选择事件
            const hybridizationOptions = document.querySelectorAll('.hybridization-option');
            hybridizationOptions.forEach(option => {
                option.addEventListener('click', () => {
                    hybridizationOptions.forEach(opt => opt.classList.remove('active'));
                    option.classList.add('active');
                    currentHybridization = option.getAttribute('data-hybridization');
                    updateOrbitals();
                    updateInfoPanel();
                });
            });
            
            // 氢原子显示开关事件
            const hydrogenToggle = document.getElementById('showHydrogen');
            hydrogenToggle.addEventListener('change', () => {
                updateHydrogenAtoms();
                updateElectrons();
            });
            
            // 电子显示开关事件
            const electronsToggle = document.getElementById('showElectrons');
            electronsToggle.addEventListener('change', () => {
                updateElectrons();
                updatePiBonds();
            });
            
            // 停止旋转开关事件
            const stopRotationToggle = document.getElementById('stopRotation');
            stopRotationToggle.addEventListener('change', (e) => {
                stopRotation = e.target.checked;
            });
            
            // 距离滑块事件
            const distanceSlider = document.getElementById('distanceSlider');
            distanceSlider.addEventListener('input', () => {
                updateAtomPositions();
            });
            
            // 激发状态事件
            const leftExcitationToggle = document.getElementById('leftExcitation');
            leftExcitationToggle.addEventListener('change', (e) => {
                leftExcitation = e.target.checked;
                updateOrbitalDiagrams();
                updateElectrons();
                updatePiBonds();
            });
            
            const rightExcitationToggle = document.getElementById('rightExcitation');
            rightExcitationToggle.addEventListener('change', (e) => {
                rightExcitation = e.target.checked;
                updateOrbitalDiagrams();
                updateElectrons();
                updatePiBonds();
            });
            
            // 初始更新信息面板
            updateInfoPanel();
        });
    </script>
</body>
</html>